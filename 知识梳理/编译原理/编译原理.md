## 编译原理

前置：
-  [`AST`抽象语法树](./ast.md)
   - [线上抽象语法树结构演示](https://astexplorer.net/) 
- [编译原理科普](https://juejin.cn/post/6958347736924192782)

##### 编译器
工作流程：分为三个阶段 `解析(parse)`、`转换(Transformation)`、`代码生成(Code Generation)`
- 解析（parse）
  - 词法分析
      把字符串形式的代码转换为 令牌（tokens） 流
      ==将输入的代码分割成为了一个 tokens 的数组==

  - 语法分析 
      一个令牌流转换成 AST 的形式。 
      ==将 tokens 进行语法分析从而转化成为真正的抽象语法树（AST）形式。==
- 转换（Transformaiton）
  - 转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作 
- 代码生成 (Code Generation)
  代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。.

  代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。

##### 转译器
转译器也是编译器的一种，只不过比较特殊，叫做 transpiler，一般的编译器叫做compiler

转译器的目标代码也是高级语言，也是嵌套的结构

转译器都是 `parse`、`transform`、`generate` 这3个阶段

##### 解释器
解释器和编译器的区别确实是是否生成代码，提前编译成机器代码的叫做 `AOT` 编译器，运行时编译成机器代码的叫做 `JIT` 编译器

解释器并不生成机器代码,是用一门高级语言来解释另一门高级语言, 比如：用c++来写js解释器，像v8、spidermonkey等都是

引入字节码，可以缓存，下次再直接执行字节码就不需要parse

一般解释线性代码的比如汇编代码、字节码等这种的程序才叫做虚拟机

不管是解释 ast 也好，还是转成字节码再解释也好，效率都不会特别高，因为是用别的高级语言来执行当前语言的代码，所以要提高效率还是得编译成机器代码，这种运行时编译就是JIT编译器，编译是耗时的，所以也不是啥代码都JIT，要做热度的统计，到达了阈值才会做JIT。然后把机器码缓存下来，当然也可能是缓存的汇编代码，用到的时候再用汇编器转成机器码，因为机器代码占的空间比较大

**应用**
- 工程化领域各种==转译器==： babel、typescript、eslint、terser、prettier、postcss、posthtml、taro、vue template compiler等
- js引擎(==解释器==)： v8、javascriptcore、quickjs、hermes等

##### babel
es6+ 转 es5 的编译器

**babel 与 polyfill的区别**
- babel是为了转译es6+ 新语法: 
  - 箭头函数
  - `??` `?.`   
  - `let` `const`等
- polyfill就是为了补齐ES6等高版本的API，新增的API
  - Promise
  - Map Set Symbol Proxy等 