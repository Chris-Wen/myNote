## 按需加载(懒加载)原理

**问题：如何实现按需加载**

> 懒加载的本质实际上就是代码分离。把代码分离到不同的 bundle 中，然后按需加载或并行加载这些文件。

前置：

- 如何实现代码分割
  - 入口起点：使用 entry 配置手动地分离代码。
  - 防止重复：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。
  - 动态导入：通过模块的内联函数调用来分离代码。

##### 动态导入

- 动态创建 script 标签，并将 src 属性指向对应的文件路径
  - 存在问题：
    > 1、如何保证相同文件只加载一次
    > 2、如何判断文件加载完成
    > 3、文件加载完成后，如何通知引入文件的地方

##### webpack 按需加载原理

动态导入

- import 语法
- require.ensure - 不推荐

![alt](../images/webpack%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD.png)

**简答：**
1、怎么保证相同的文件只加载一次？
​ 定义 installedChunks 对象，存储异步 js 的 promise 回调，如果已经加载过，则返回一个空数组的 promise.all([])，如果在加载过程中，则返回已经存储过的此文件对应的 promise。

2、怎么判断文件加载完成？
​ 1、在主文件中定义一个全局数组，并重写其 push 方法，在异步文件中执行此全局数组的 push 方法。
​ 2、在重写的方法中执行 promise 的 resolve 回调。

3、文件加载完成后，怎么通知所有引入文件的地方？
同 2

- webpack 如何实现模块化

  - es module ： export / import
  - commonjs : requires / export
    引入导出方式不同

    大致流程
    1、用一个全局对象 modules 存放所有的模块，key、value 对应 moduleId 和模块函数
    2、从入口开始加载其他模块：
    `webpack_require.e`动态插入 script 标签，在 chunk 加载完成后会把 chunk 里面所有的模块和对应的模块函数加入到 modules 对象里面
    3、模块加载函数执行完了，会把结果缓存到`installedModules`中，然后返回导出值,下次直接从 缓存`installedModules`中取
