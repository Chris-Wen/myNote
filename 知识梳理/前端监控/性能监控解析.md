## 前端监控解析
[前端性能监控Performance](https://juejin.cn/post/7031572366341701663)

性能监控监控什么？
1、 首屏加载时间
2、 白屏时间
3、 http 等请求的响应时间
4、 静态资源整体下载时间
5、 页面渲染时间
6、 页面交互动画完成时间

异常监控？
1、 Javascript 的异常监控
2、 样式丢失的异常监控

#### 概念
- 首屏加载时间：指页面完全加载完所用的时间，这时候触发完成了 onload 事件
- ==首屏时间==：也称用户完全可交互时间，即整个页面首屏完全渲染出来，用户完全可以交互，**一般首屏时间小于页面完全加载时间，该指标值可以衡量页面访问速度** 
- ==白屏时间==：首次渲染时间，指页面出现第一个文字或图像所花费的时间

##### 性能指标
1、**FP: 首次绘制**  
 First Paint
2、**FCP：首次内容绘制**  
 First ContentFul Paint 标记的是浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG等
3、**FMP：首次有效绘制** 
First Meaningful Paint：首次有效绘制，标记主角元素渲染完成的时间点，主角元素可以是视频网站的视频控件，内容网站的页面框架也可以是资源网站的头图等
4、**TTI：页面可交互时间** 
Time to Interactive：页面可交互时间，即从页面开始加载，一直到用户可以自由输入或操作页面的时间


### window.performance
##### 1. 属性
1、navigation 返回一个 PerformanceNavigation 对象。这个对象表示出现在当前浏览上下文的 navigation 类型，比如获取某个资源所需要的重定向次数
```
PerformanceNavigation {
    type: 0,  //表示是如何导航到这个页面的
    redirectCount: 0  //表示在到达这个页面之前重定向了多少次
}

redirectCount值
- 0：当前页面是通过点击链接，书签和表单提交，或者脚本操作，或者在url中直接输入地址
- 1：点击刷新页面按钮或者通过Location.reload()方法显示的页面
- 2：页面通过历史记录和前进后退访问时
- 255：任何其他方式
```

2、timing: 已弃用，用 ==window.performance.getEntriesByType('navigation')代替==

3、memory: 基本内存使用情况

##### 2.timing渲染顺序
![alt](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4854a0730a814384b257926da7ed5b6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)


### 各指标计算方式

指标 | 计算方式 | 说明
---|--- | ---
页面加载总耗时/页面加载完时间 | loadEventEnd - startTime | 加载到onload事件触发
资源加载耗时 | loadEventEnd - domContentLoadedEventEnd | 指 DOM 解析完成后到页面完全加载完所用的时间
页面渲染耗时 | loadEventEnd - responseEnd 
==白屏时间== | 优先使用最新标准 performance.getEntriesByType('paint')[0].startTime，不支持的话使用 Chrome、IE 提供的 firstPaintTime，chrome.loadTimes().firstPaintTime 或 performance.msFirstPaint，还没有获取，取 domInteractive - startTime但是实际上报取的值是：loadEventEnd - startTime | 首次渲染时间，指页面出现第一个文字或图像所花费的时间
==首屏时间== | 1、通过计算首屏区域内的所有图片加载时间，然后取其最大值；<br/>2、通过 window.MutationObserver 来监听首屏所有元素变化情况，并记录时间，最后取其最大值（会去掉得分相同重复的值），算出的时间需要加上 domInteractive（可交互时间）；<br/>目前系统采用第二种实现方式，如果第二种取不到，取 domInteractive，但该值会比实际首屏时间要小 | 首屏时间，也称用户完全可交互时间，即整个页面首屏完全渲染出来，用户完全可以交互，一般首屏时间小于页面完全加载时间，该指标值可以衡量页面访问速度

-----
#### ==首屏时间==
我们知道首屏时间是一项重要指标，但是又很难从 performance 中拿到，来看下首屏时间计算主要有哪些方式？
- 用户自定义打点—最准确的方式（只有用户自己最清楚，什么样的时间才算是首屏加载完成）
- lighthouse 中使用的是 chrome 渲染过程中记录的 trace event
可利用 Chrome DevTools Protocol 拿到页面布局节点数目。思想是：获取到当页面具有最大布局变化的时间点
- aegis 的方法：利用 MutationObserver 接口，监听 document 对象的节点变化。
- 检查这些变化的节点是否显示在首屏中，若这些节点在首屏中，那当前的时间点即为首屏渲染时间。但是还有首屏内图片的加载时间需要考虑，遍历 performance.getEntries() 拿到的所有图片实体对象，根据图片的初始加载时间和加载完成时间去更新首屏渲染时间。
- 利用 MutationObserver 接口提供了监视对 DOM 树所做更改的能力，是 DOM3 Events 规范的一部分。
- 某个专利：在 loading 状态下循环判断当前页面高度是否大于屏幕高度，若大于，则获取到当前页面的屏幕图像，通过逐像素对比来判断页面渲染是否已满屏。

---
额外参考：
[如何进行web性能监控](http://www.alloyteam.com/2020/01/14184/#prettyPhoto)

---
第三方监控平台：
- Webfunny - 收费、支持ESC部署和Docker部署、轻量级
- sentry - 开源，需要自己折腾、维护
- fundebug - 只支持异常监控





