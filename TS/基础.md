## TS基础


#### 类型
1、函数
```ts
function identify <T> (value: T) : T {
    return value
}
//第一个T表示函数参数类型
//第三个T表示函数返回类型

//多个传递类型
function identify <T, U> (value: T, message: U) : void {
    ...
}
```
![alt](https://imgconvert.csdnimg.cn/aHR0cDovL2Nkbi5zZW1saW5rZXIuY29tL2dlbmVyaWMtbXVsdGktdHlwZS1maWxsZWQuanBn?x-oss-process=image/format,png)


#### 配置


#### 类


#### 接口与泛型
1、接口 - `interface`
- 定义对象
    ```ts
    interface myInterface{
        name:string,
        age:number
    }
    ```
- 定义数组**定义属性名时，要用index**
    ```ts
    interface Obj {
        [propName:string]:any
    }

    interface myList {
        [index:number|string]:Obj
    }

    const arr:myList = [
        {name:"黑猫警长"}
    ]
    ```
- 接口的继承`extends`,且后可以跟多个接口，实现多重继承
    ```ts
    interface IPerson extends myInterface,Obj{
        sex:"male"|"female",
        sayName():void
    }
    ```



2、==泛型 - `T`== - **指定函数/类**
> 在指定函数或者类的时候，如果遇到类型不明确的话，就可以使用泛型(不先指定类型，使用的时候进行类型的转换)
- 泛型函数
![alt](https://imgconvert.csdnimg.cn/aHR0cDovL2Nkbi5zZW1saW5rZXIuY29tL2dlbmVyaWMtbXVsdGktdHlwZS1maWxsZWQuanBn?x-oss-process=image/format,png)

- 泛型接口 
- 泛型类
- 泛型约束
- 泛型参数默认类型 `<T=Default Type>`
    ```ts
    interface A<T=string> {
        name: T;
    }
    ```
- 泛型条件类型
- 泛型工具类型
    - Partial - `Partial<T>`的作用就是将某个类型里的属性全部变为可选项 ?
    - Record
    - Pick
    - Exclude
    - ReturnType
- 使用泛型创建对象

#### 其他
- .d.ts文件 - 模块类库声明文件
    - 必须以`declare`开头
        - ==`declare`声明的变量和模块后，其他地方不需要引入，就可以直接使用了==

        ```TS
        //声明一个模块
        declare module '*.css'; 
        //声明一个变量
        declare var jQuery: (selector: string) => any;
        //声明一个类型
        declare type Person { name: string }
        //声明一个作用域
        declare namespace API {
            interface ResponseObj{
                ...
            }
            ...
        }
        ```
    - **注意**
        - `declare` 与`export` 不要同级使用，不然的话，声明文件就需要导入了
        - 在声明文件中 `type` 与 `interface` `也可以不用加declare` ，效果相同


- `namespace` 与 `module`
    - 在实际语法上，`namespace` 等同于 `module`
    - `namespace`主要用于解决命名冲突
    - `namespace`是跨文件的，在任何ts文件中都可以使用

- 通过reference进行导入相当于xxx.ts文件内的命名空间和当前文件进行了合并
    ```ts
    /// <reference path="单文件.ts" />
    const person1:Validation.PersonValidator = {
        name:"猪八戒",
        age:18
    }
    console.log(person)
    console.log(person1)

    //这里相当于两个文件进行了合并，我们也可以访问到合并文件中定义的变量
    ```

- `typeof` 与 `keyof`
    - `typeof`
        - js中是用来获取变量类型的
        - ts中一般用来获取一个变量的定义的类型，**一般他用在定义变量的后面说明类型**，如果是用到非定义变量时，那么就是js中的用法了
        ```ts
        const dog = {
            name: "wangcai",
            age: 18
        }

        let dogType: typeof dog;
        ```
    - `keyof`
        - 一般获取某种类型的键，直接返回**联合类型**
        - keyof后面跟一种类型，不能跟具体的值，也常常与typeof一起使用
        ```ts
        const TangSeng = {
            name: "tangseng",
            age: 18
        }

        let key:keyof typeof TangSeng

        //对象读取时，可能会用到keyof
        const TangSeng = {
            name: "tangseng",
            age: 18
        }

        type key = keyof typeof TangSeng

        function fn(param:key){
            return TangSeng[param]
        }
        ```